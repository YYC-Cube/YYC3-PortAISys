# YYCÂ³ PortAISys - å®‰å…¨ç®¡ç†æŒ‡å—

> ***YanYuCloudCube***
> è¨€å¯è±¡é™ | è¯­æ¢æœªæ¥
> ***Words Initiate Quadrants, Language Serves as Core for the Future***
> ä¸‡è±¡å½’å…ƒäºäº‘æ¢ | æ·±æ ˆæ™ºå¯æ–°çºªå…ƒ
> ***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***

---

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0
> **åˆ›å»ºæ—¥æœŸ**: 2026-02-03
> **æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ
> **ç»´æŠ¤å›¢é˜Ÿ**: YYCÂ³ äº§å“å›¢é˜Ÿ

---

## ğŸ“‹ ç›®å½•

- [å®‰å…¨æ¦‚è¿°](#å®‰å…¨æ¦‚è¿°)
- [èº«ä»½è®¤è¯](#èº«ä»½è®¤è¯)
- [è®¿é—®æ§åˆ¶](#è®¿é—®æ§åˆ¶)
- [æ•°æ®å®‰å…¨](#æ•°æ®å®‰å…¨)
- [ç½‘ç»œå®‰å…¨](#ç½‘ç»œå®‰å…¨)
- [å®‰å…¨å®¡è®¡](#å®‰å…¨å®¡è®¡)
- [åˆè§„æ€§](#åˆè§„æ€§)

---

## å®‰å…¨æ¦‚è¿°

### å®‰å…¨æ¶æ„

YYCÂ³ é‡‡ç”¨å¤šå±‚æ¬¡çš„å®‰å…¨æ¶æ„ï¼Œç¡®ä¿ç³»ç»Ÿã€æ•°æ®å’Œç”¨æˆ·çš„å®‰å…¨ã€‚

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  YYCÂ³ å®‰å…¨æ¶æ„                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                       â”‚
â”‚  â”‚  ç½‘ç»œå±‚å®‰å…¨  â”‚â”€â”€â”€â–¶ é˜²ç«å¢™ã€DDoSé˜²æŠ¤ã€TLSåŠ å¯†          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                                       â”‚
â”‚         â”‚                                               â”‚
â”‚         â–¼                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                       â”‚
â”‚  â”‚  åº”ç”¨å±‚å®‰å…¨  â”‚â”€â”€â”€â–¶ èº«ä»½è®¤è¯ã€è®¿é—®æ§åˆ¶ã€è¾“å…¥éªŒè¯        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                                       â”‚
â”‚         â”‚                                               â”‚
â”‚         â–¼                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                       â”‚
â”‚  â”‚  æ•°æ®å±‚å®‰å…¨  â”‚â”€â”€â”€â–¶ æ•°æ®åŠ å¯†ã€å¤‡ä»½ã€å®¡è®¡æ—¥å¿—            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                                       â”‚
â”‚         â”‚                                               â”‚
â”‚         â–¼                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                       â”‚
â”‚  â”‚  è¿ç»´å±‚å®‰å…¨  â”‚â”€â”€â”€â–¶ å®‰å…¨ç›‘æ§ã€æ¼æ´æ‰«æã€åº”æ€¥å“åº”        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                       â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### å®‰å…¨åŸåˆ™

- **æœ€å°æƒé™åŸåˆ™**: ç”¨æˆ·åªæ‹¥æœ‰å®Œæˆå·¥ä½œæ‰€éœ€çš„æœ€å°æƒé™
- **çºµæ·±é˜²å¾¡**: å¤šå±‚æ¬¡å®‰å…¨é˜²æŠ¤
- **é›¶ä¿¡ä»»**: ä¸ä¿¡ä»»ä»»ä½•å†…éƒ¨æˆ–å¤–éƒ¨ç½‘ç»œ
- **å®‰å…¨é»˜è®¤**: é»˜è®¤é…ç½®å®‰å…¨
- **æŒç»­ç›‘æ§**: æŒç»­ç›‘æ§å’Œå®¡è®¡

---

## èº«ä»½è®¤è¯

### JWTè®¤è¯

#### é…ç½®JWT

```typescript
import jwt from 'jsonwebtoken';

interface JWTPayload {
  userId: string;
  email: string;
  role: string;
  permissions: string[];
}

class AuthService {
  private secret: string;
  private expiresIn: string;

  constructor() {
    this.secret = process.env.JWT_SECRET || 'your-secret-key';
    this.expiresIn = process.env.JWT_EXPIRES_IN || '24h';
  }

  /**
   * ç”ŸæˆJWTä»¤ç‰Œ
   */
  generateToken(payload: JWTPayload): string {
    return jwt.sign(payload, this.secret, {
      expiresIn: this.expiresIn,
      issuer: 'yyc3-portaisys',
      audience: 'yyc3-users'
    });
  }

  /**
   * éªŒè¯JWTä»¤ç‰Œ
   */
  verifyToken(token: string): JWTPayload | null {
    try {
      const decoded = jwt.verify(token, this.secret) as JWTPayload;
      return decoded;
    } catch (error) {
      return null;
    }
  }

  /**
   * åˆ·æ–°JWTä»¤ç‰Œ
   */
  refreshToken(token: string): string | null {
    const payload = this.verifyToken(token);
    if (!payload) {
      return null;
    }

    // ç”Ÿæˆæ–°ä»¤ç‰Œ
    return this.generateToken({
      userId: payload.userId,
      email: payload.email,
      role: payload.role,
      permissions: payload.permissions
    });
  }
}
```

#### ä½¿ç”¨JWTä¸­é—´ä»¶

```typescript
import { Request, Response, NextFunction } from 'express';

function authMiddleware(req: Request, res: Response, next: NextFunction) {
  const authHeader = req.headers.authorization;

  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({
      success: false,
      error: {
        code: 'E004',
        message: 'æœªæˆæƒï¼šç¼ºå°‘è®¤è¯ä»¤ç‰Œ'
      }
    });
  }

  const token = authHeader.substring(7);
  const authService = new AuthService();
  const payload = authService.verifyToken(token);

  if (!payload) {
    return res.status(401).json({
      success: false,
      error: {
        code: 'E004',
        message: 'æœªæˆæƒï¼šæ— æ•ˆæˆ–è¿‡æœŸçš„ä»¤ç‰Œ'
      }
    });
  }

  // å°†ç”¨æˆ·ä¿¡æ¯é™„åŠ åˆ°è¯·æ±‚å¯¹è±¡
  req.user = payload;
  next();
}

// ä½¿ç”¨ä¸­é—´ä»¶
app.get('/api/v1/users/me', authMiddleware, async (req, res) => {
  const user = await getUserById(req.user.userId);
  res.json({ success: true, data: user });
});
```

### OAuth 2.0

#### é…ç½®OAuth

```typescript
import { OAuth2Client } from 'google-auth-library';

class OAuthService {
  private googleClient: OAuth2Client;

  constructor() {
    this.googleClient = new OAuth2Client(
      process.env.GOOGLE_CLIENT_ID,
      process.env.GOOGLE_CLIENT_SECRET,
      process.env.GOOGLE_REDIRECT_URI
    );
  }

  /**
   * è·å–æˆæƒURL
   */
  getAuthUrl(): string {
    const authUrl = this.googleClient.generateAuthUrl({
      access_type: 'offline',
      scope: ['profile', 'email'],
      prompt: 'consent'
    });

    return authUrl;
  }

  /**
   * è·å–ä»¤ç‰Œ
   */
  async getToken(code: string) {
    const { tokens } = await this.googleClient.getToken(code);
    return tokens;
  }

  /**
   * éªŒè¯ä»¤ç‰Œ
   */
  async verifyToken(idToken: string) {
    const ticket = await this.googleClient.verifyIdToken({
      idToken,
      audience: process.env.GOOGLE_CLIENT_ID
    });

    const payload = ticket.getPayload();
    return payload;
  }
}
```

### å¤šå› ç´ è®¤è¯

#### å®ç°MFA

```typescript
import speakeasy from 'speakeasy';
import QRCode from 'qrcode';

class MFAService {
  /**
   * ç”ŸæˆMFAå¯†é’¥
   */
  generateSecret(userId: string) {
    const secret = speakeasy.generateSecret({
      name: `YYCÂ³ (${userId})`,
      issuer: 'YYCÂ³ PortAISys',
      length: 32
    });

    return {
      secret: secret.base32,
      qrCode: secret.otpauth_url
    };
  }

  /**
   * éªŒè¯MFAä»£ç 
   */
  verifyToken(secret: string, token: string): boolean {
    return speakeasy.totp.verify({
      secret,
      encoding: 'base32',
      token,
      window: 2
    });
  }

  /**
   * ç”ŸæˆQRç 
   */
  async generateQRCode(otpauthUrl: string): Promise<string> {
    return QRCode.toDataURL(otpauthUrl);
  }
}
```

---

## è®¿é—®æ§åˆ¶

### RBACæƒé™æ¨¡å‹

#### å®šä¹‰è§’è‰²å’Œæƒé™

```typescript
enum Role {
  ADMIN = 'ADMIN',
  USER = 'USER',
  GUEST = 'GUEST'
}

enum Permission {
  // ç”¨æˆ·æƒé™
  USER_READ = 'user:read',
  USER_WRITE = 'user:write',
  USER_DELETE = 'user:delete',

  // å·¥ä½œæµæƒé™
  WORKFLOW_READ = 'workflow:read',
  WORKFLOW_WRITE = 'workflow:write',
  WORKFLOW_EXECUTE = 'workflow:execute',
  WORKFLOW_DELETE = 'workflow:delete',

  // AIæƒé™
  AI_CHAT = 'ai:chat',
  AI_ANALYZE = 'ai:analyze',

  // ç³»ç»Ÿæƒé™
  SYSTEM_READ = 'system:read',
  SYSTEM_WRITE = 'system:write',
  SYSTEM_ADMIN = 'system:admin'
}

// è§’è‰²æƒé™æ˜ å°„
const ROLE_PERMISSIONS: Record<Role, Permission[]> = {
  [Role.ADMIN]: Object.values(Permission),
  [Role.USER]: [
    Permission.USER_READ,
    Permission.USER_WRITE,
    Permission.WORKFLOW_READ,
    Permission.WORKFLOW_WRITE,
    Permission.WORKFLOW_EXECUTE,
    Permission.AI_CHAT,
    Permission.AI_ANALYZE,
    Permission.SYSTEM_READ
  ],
  [Role.GUEST]: [
    Permission.USER_READ,
    Permission.WORKFLOW_READ,
    Permission.AI_CHAT
  ]
};
```

#### å®ç°æƒé™æ£€æŸ¥

```typescript
class RBACService {
  /**
   * æ£€æŸ¥ç”¨æˆ·æƒé™
   */
  hasPermission(userRole: Role, permission: Permission): boolean {
    const permissions = ROLE_PERMISSIONS[userRole] || [];
    return permissions.includes(permission);
  }

  /**
   * æ£€æŸ¥å¤šä¸ªæƒé™
   */
  hasAllPermissions(userRole: Role, permissions: Permission[]): boolean {
    return permissions.every(permission =>
      this.hasPermission(userRole, permission)
    );
  }

  /**
   * æ£€æŸ¥ä»»ä¸€æƒé™
   */
  hasAnyPermission(userRole: Role, permissions: Permission[]): boolean {
    return permissions.some(permission =>
      this.hasPermission(userRole, permission)
    );
  }
}

// æƒé™ä¸­é—´ä»¶
function requirePermission(permission: Permission) {
  return (req: Request, res: Response, next: NextFunction) => {
    const rbacService = new RBACService();

    if (!rbacService.hasPermission(req.user.role, permission)) {
      return res.status(403).json({
        success: false,
        error: {
          code: 'E005',
          message: 'æƒé™ä¸è¶³'
        }
      });
    }

    next();
  };
}

// ä½¿ç”¨ç¤ºä¾‹
app.delete('/api/v1/workflows/:id',
  authMiddleware,
  requirePermission(Permission.WORKFLOW_DELETE),
  async (req, res) => {
    await deleteWorkflow(req.params.id);
    res.json({ success: true });
  }
);
```

### APIå¯†é’¥ç®¡ç†

#### ç”ŸæˆAPIå¯†é’¥

```typescript
import crypto from 'crypto';

class APIKeyService {
  /**
   * ç”ŸæˆAPIå¯†é’¥
   */
  generateKey(): string {
    const prefix = 'yyc3_';
    const key = crypto.randomBytes(32).toString('hex');
    return `${prefix}${key}`;
  }

  /**
   * å“ˆå¸ŒAPIå¯†é’¥
   */
  hashKey(key: string): string {
    return crypto.createHash('sha256').update(key).digest('hex');
  }

  /**
   * éªŒè¯APIå¯†é’¥
   */
  verifyKey(key: string, hashedKey: string): boolean {
    return this.hashKey(key) === hashedKey;
  }

  /**
   * åˆ›å»ºAPIå¯†é’¥
   */
  async createAPIKey(userId: string, scopes: string[]) {
    const key = this.generateKey();
    const hashedKey = this.hashKey(key);

    const apiKey = await prisma.apiKey.create({
      data: {
        userId,
        key: hashedKey,
        scopes,
        expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000) // 30å¤©
      }
    });

    return {
      id: apiKey.id,
      key,                           // åªè¿”å›ä¸€æ¬¡
      scopes: apiKey.scopes,
      expiresAt: apiKey.expiresAt
    };
  }
}
```

---

## æ•°æ®å®‰å…¨

### æ•°æ®åŠ å¯†

#### å¯¹ç§°åŠ å¯†

```typescript
import crypto from 'crypto';

class EncryptionService {
  private algorithm = 'aes-256-gcm';
  private key: Buffer;
  private ivLength = 16;

  constructor() {
    const key = process.env.ENCRYPTION_KEY || 'your-32-byte-encryption-key';
    this.key = Buffer.from(key, 'hex');
  }

  /**
   * åŠ å¯†æ•°æ®
   */
  encrypt(text: string): string {
    const iv = crypto.randomBytes(this.ivLength);
    const cipher = crypto.createCipheriv(this.algorithm, this.key, iv);

    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');

    const authTag = cipher.getAuthTag();

    // ç»„åˆIVã€åŠ å¯†æ•°æ®å’Œè®¤è¯æ ‡ç­¾
    const combined = Buffer.concat([iv, Buffer.from(encrypted, 'hex'), authTag]);
    return combined.toString('base64');
  }

  /**
   * è§£å¯†æ•°æ®
   */
  decrypt(encryptedText: string): string {
    const combined = Buffer.from(encryptedText, 'base64');

    const iv = combined.slice(0, this.ivLength);
    const encrypted = combined.slice(this.ivLength, -16);
    const authTag = combined.slice(-16);

    const decipher = crypto.createDecipheriv(this.algorithm, this.key, iv);
    decipher.setAuthTag(authTag);

    let decrypted = decipher.update(encrypted, null, 'utf8');
    decrypted += decipher.final('utf8');

    return decrypted;
  }
}
```

#### å­—æ®µçº§åŠ å¯†

```typescript
import { Prisma } from '@prisma/client';

// Prismaä¸­é—´ä»¶å®ç°å­—æ®µçº§åŠ å¯†
const encryptionService = new EncryptionService();

prisma.$use(async (params, next) => {
  // åŠ å¯†æ•æ„Ÿå­—æ®µ
  if (params.action === 'create' || params.action === 'update') {
    if (params.args.data) {
      const data = params.args.data;

      if (data.email) {
        data.email = encryptionService.encrypt(data.email);
      }
      if (data.phone) {
        data.phone = encryptionService.encrypt(data.phone);
      }
    }
  }

  // è§£å¯†æ•æ„Ÿå­—æ®µ
  if (params.action === 'findUnique' || params.action === 'findFirst' || params.action === 'findMany') {
    const result = await next(params);

    if (result) {
      if (Array.isArray(result)) {
        return result.map(item => decryptFields(item));
      } else {
        return decryptFields(result);
      }
    }

    return result;
  }

  return next(params);
});

function decryptFields(data: any): any {
  if (data.email) {
    data.email = encryptionService.decrypt(data.email);
  }
  if (data.phone) {
    data.phone = encryptionService.decrypt(data.phone);
  }
  return data;
}
```

### æ•°æ®è„±æ•

```typescript
class DataMaskingService {
  /**
   * è„±æ•é‚®ç®±
   */
  maskEmail(email: string): string {
    const [username, domain] = email.split('@');
    const maskedUsername = username.substring(0, 2) + '***';
    return `${maskedUsername}@${domain}`;
  }

  /**
   * è„±æ•æ‰‹æœºå·
   */
  maskPhone(phone: string): string {
    return phone.replace(/(\d{3})\d{4}(\d{4})/, '$1****$2');
  }

  /**
   * è„±æ•èº«ä»½è¯å·
   */
  maskIdCard(idCard: string): string {
    return idCard.replace(/(\d{6})\d{8}(\d{4})/, '$1********$2');
  }

  /**
   * è„±æ•é“¶è¡Œå¡å·
   */
  maskBankCard(cardNumber: string): string {
    return cardNumber.replace(/(\d{4})\d{8}(\d{4})/, '$1********$2');
  }
}
```

---

## ç½‘ç»œå®‰å…¨

### CORSé…ç½®

```typescript
import cors from 'cors';

const corsOptions = {
  origin: function (origin: string | undefined, callback: any) {
    const allowedOrigins = [
      'https://your-domain.com',
      'https://www.your-domain.com'
    ];

    if (!origin || allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      callback(new Error('ä¸å…è®¸çš„CORSæº'));
    }
  },
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  credentials: true,
  maxAge: 86400  // 24å°æ—¶
};

app.use(cors(corsOptions));
```

### å®‰å…¨å¤´é…ç½®

```typescript
import helmet from 'helmet';

app.use(helmet({
  // X-Frame-Options
  frameguard: {
    action: 'sameorigin'
  },

  // X-Content-Type-Options
  noSniff: true,

  // X-XSS-Protection
  xssFilter: true,

  // Strict-Transport-Security
  hsts: {
    maxAge: 31536000,  // 1å¹´
    includeSubDomains: true,
    preload: true
  },

  // Content-Security-Policy
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'", "'unsafe-inline'", "'unsafe-eval'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      imgSrc: ["'self'", 'data:', 'https:'],
      fontSrc: ["'self'", 'data:'],
      connectSrc: ["'self'", 'https:'],
      frameAncestors: ["'self'"]
    }
  },

  // Referrer-Policy
  referrerPolicy: { policy: 'strict-origin-when-cross-origin' },

  // Permissions-Policy
  permissionsPolicy: {
    features: {
      camera: ["'none'"],
      microphone: ["'none'"],
      geolocation: ["'none'"]
    }
  }
}));
```

### é€Ÿç‡é™åˆ¶

```typescript
import rateLimit from 'express-rate-limit';

// é€šç”¨é€Ÿç‡é™åˆ¶
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000,  // 15åˆ†é’Ÿ
  max: 100,                    // æœ€å¤š100ä¸ªè¯·æ±‚
  message: {
    success: false,
    error: {
      code: 'E007',
      message: 'è¯·æ±‚è¿‡å¤šï¼Œè¯·ç¨åå†è¯•'
    }
  },
  standardHeaders: true,
  legacyHeaders: false,
  skip: (req) => {
    // è·³è¿‡å¥åº·æ£€æŸ¥ç«¯ç‚¹
    return req.path === '/health';
  }
});

app.use('/api/', limiter);

// ä¸¥æ ¼é€Ÿç‡é™åˆ¶ï¼ˆç™»å½•ç­‰æ•æ„Ÿæ“ä½œï¼‰
const strictLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 5,
  message: {
    success: false,
    error: {
      code: 'E007',
      message: 'ç™»å½•å°è¯•è¿‡å¤šï¼Œè¯·15åˆ†é’Ÿåå†è¯•'
    }
  }
});

app.post('/api/v1/auth/login', strictLimiter);
```

---

## å®‰å…¨å®¡è®¡

### å®¡è®¡æ—¥å¿—

```typescript
interface AuditLog {
  id: string;
  userId: string;
  action: string;
  resource: string;
  resourceId?: string;
  ipAddress: string;
  userAgent: string;
  timestamp: Date;
  success: boolean;
  details?: any;
}

class AuditService {
  /**
   * è®°å½•å®¡è®¡æ—¥å¿—
   */
  async log(entry: Omit<AuditLog, 'id' | 'timestamp'>): Promise<void> {
    await prisma.auditLog.create({
      data: {
        ...entry,
        timestamp: new Date()
      }
    });

    // åŒæ—¶å‘é€åˆ°SIEMç³»ç»Ÿ
    await this.sendToSIEM(entry);
  }

  /**
   * æŸ¥è¯¢å®¡è®¡æ—¥å¿—
   */
  async query(filters: {
    userId?: string;
    action?: string;
    resource?: string;
    startDate?: Date;
    endDate?: Date;
  }): Promise<AuditLog[]> {
    return prisma.auditLog.findMany({
      where: {
        ...filters,
        timestamp: {
          ...(filters.startDate && { gte: filters.startDate }),
          ...(filters.endDate && { lte: filters.endDate })
        }
      },
      orderBy: { timestamp: 'desc' }
    });
  }

  /**
   * å‘é€åˆ°SIEMç³»ç»Ÿ
   */
  private async sendToSIEM(entry: Omit<AuditLog, 'id' | 'timestamp'>): Promise<void> {
    // å®ç°SIEMé›†æˆ
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const auditService = new AuditService();

app.post('/api/v1/auth/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    const user = await authenticate(email, password);

    await auditService.log({
      userId: user.id,
      action: 'login',
      resource: 'auth',
      ipAddress: req.ip,
      userAgent: req.headers['user-agent'],
      success: true
    });

    res.json({ success: true, data: user });
  } catch (error) {
    await auditService.log({
      userId: 'unknown',
      action: 'login',
      resource: 'auth',
      ipAddress: req.ip,
      userAgent: req.headers['user-agent'],
      success: false,
      details: { error: error.message }
    });

    res.status(401).json({
      success: false,
      error: {
        code: 'E004',
        message: 'è®¤è¯å¤±è´¥'
      }
    });
  }
});
```

---

## åˆè§„æ€§

### GDPRåˆè§„

```typescript
class GDPRService {
  /**
   * æ•°æ®å¯¼å‡ºï¼ˆç”¨æˆ·æ•°æ®å¯æºå¸¦æƒï¼‰
   */
  async exportUserData(userId: string): Promise<any> {
    const user = await prisma.user.findUnique({
      where: { id: userId },
      include: {
        orders: true,
        workflows: true,
        auditLogs: true
      }
    });

    return user;
  }

  /**
   * æ•°æ®åˆ é™¤ï¼ˆè¢«é—å¿˜æƒï¼‰
   */
  async deleteUserData(userId: string): Promise<void> {
    await prisma.$transaction([
      // åˆ é™¤ç”¨æˆ·æ•°æ®
      prisma.auditLog.deleteMany({ where: { userId } }),
      prisma.workflow.deleteMany({ where: { userId } }),
      prisma.order.deleteMany({ where: { userId } }),
      prisma.user.delete({ where: { id: userId } })
    ]);
  }

  /**
   * æ•°æ®å¤„ç†åŒæ„
   */
  async recordConsent(userId: string, consentType: string): Promise<void> {
    await prisma.consent.create({
      data: {
        userId,
        consentType,
        grantedAt: new Date(),
        ipAddress: '0.0.0.0'  // ä»è¯·æ±‚ä¸­è·å–
      }
    });
  }
}
```

### SOC 2åˆè§„

```typescript
class SOC2Service {
  /**
   * è®¿é—®æ§åˆ¶å®¡è®¡
   */
  async auditAccessControls(): Promise<any> {
    const users = await prisma.user.findMany();
    const roles = await prisma.role.findMany();
    const permissions = await prisma.permission.findMany();

    return {
      users: users.length,
      roles: roles.length,
      permissions: permissions.length,
      lastAudit: new Date()
    };
  }

  /**
   * å˜æ›´ç®¡ç†
   */
  async recordChange(change: {
    type: string;
    resource: string;
    resourceId: string;
    before?: any;
    after?: any;
    changedBy: string;
  }): Promise<void> {
    await prisma.changeLog.create({
      data: {
        ...change,
        timestamp: new Date()
      }
    });
  }
}
```

---

## ä¸‹ä¸€æ­¥

- [ç›‘æ§å’Œå‘Šè­¦ç³»ç»Ÿ](./13-ç›‘æ§å’Œå‘Šè­¦ç³»ç»Ÿ.md) - ç›‘æ§é…ç½®
- [æ•…éšœæ’é™¤æŒ‡å—](./24-æ•…éšœæ’é™¤æŒ‡å—.md) - æ•…éšœæ’é™¤
- [æœ€ä½³å®è·µ](./25-æœ€ä½³å®è·µ.md) - æ›´å¤šæœ€ä½³å®è·µ

---

<div align="center">

> ã€Œ***YanYuCloudCube***ã€
> ã€Œ***<admin@0379.email>***ã€
> ã€Œ***Words Initiate Quadrants, Language Serves as Core for the Future***ã€
> ã€Œ***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***ã€

</div>
