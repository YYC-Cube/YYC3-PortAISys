# YYC³ PortAISys - 文档与代码关联映射规则设计文档

## 文档信息

**文档名称**: 文档与代码关联映射规则设计文档  
**文档版本**: v1.0  
**创建日期**: 2026-01-20  
**最后更新**: 2026-01-20  
**文档状态**: ✅ 已完成  
**负责团队**: 技术架构团队  
**负责人**: 技术架构师  

---

## 一、映射规则概述

### 1.1 设计目标

**核心目标**:
- 建立文档与代码的清晰关联关系
- 支持文档与代码的双向同步
- 实现文档与代码的版本一致性
- 提供文档与代码的变更追踪能力
- 确保文档与代码的实时同步

**预期效果**:
- 文档与代码关联准确率 100%
- 文档与代码同步延迟 < 5秒
- 文档与代码版本一致性 100%
- 文档与代码变更追踪覆盖率 100%

### 1.2 映射原则

**映射原则**:
1. **一对一映射**: 一个文档文件对应一个代码文件
2. **一对多映射**: 一个文档文件对应多个代码文件
3. **多对一映射**: 多个文档文件对应一个代码文件
4. **层级映射**: 文档目录结构与代码目录结构保持一致
5. **命名规范**: 文档文件名与代码文件名保持一致

---

## 二、映射规则设计

### 2.1 基础映射规则

#### 2.1.1 文件名映射规则

**规则说明**:
- 文档文件名与代码文件名保持一致（除扩展名外）
- 文档文件使用 `.md` 扩展名
- 代码文件使用 `.ts` 或 `.tsx` 扩展名

**映射示例**:
```
文档文件: AutonomousAIEngine.md
代码文件: AutonomousAIEngine.ts

文档文件: StateManager.md
代码文件: StateManager.ts

文档文件: TaskScheduler.md
代码文件: TaskScheduler.ts
```

#### 2.1.2 目录结构映射规则

**规则说明**:
- 文档目录结构与代码目录结构保持一致
- 文档根目录对应代码根目录
- 文档子目录对应代码子目录

**映射示例**:
```
文档目录结构:
docs/
├── YYC3-PortAISys-智能浮窗/
│   ├── 00-YYC3-PortAISys-AutonomousAIEngine实现文档.md
│   └── 00-YYC3-PortAISys-ModelAdapter实现文档.md
├── YYC3-PortAISys-代码文档/
│   └── 01-YYC3-PortAISys-代码文档-智能AI浮窗系统.md
└── YYC3-PortAISys-缺失补全/
    └── 全面分析报告.md

代码目录结构:
core/
├── autonomous-ai-widget/
│   ├── AutonomousAIEngine.ts
│   └── types.ts
├── model/
│   ├── ModelAdapter.ts
│   └── types.ts
└── state-manager/
    └── StateManager.ts
```

#### 2.1.3 命名前缀映射规则

**规则说明**:
- 文档文件名前缀对应代码模块名称
- 使用统一的命名前缀规范

**映射示例**:
```
文档文件: 00-YYC3-PortAISys-AutonomousAIEngine实现文档.md
代码模块: autonomous-ai-widget/
代码文件: AutonomousAIEngine.ts

文档文件: 00-YYC3-PortAISys-ModelAdapter实现文档.md
代码模块: model/
代码文件: ModelAdapter.ts
```

### 2.2 高级映射规则

#### 2.2.1 一对多映射规则

**规则说明**:
- 一个文档文件对应多个代码文件
- 文档文件描述一个功能模块，包含多个代码文件
- 在文档中明确列出所有关联的代码文件

**映射示例**:
```
文档文件: 01-YYC3-PortAISys-智能浮窗-核心架构.md

关联代码文件:
- core/autonomous-ai-widget/AutonomousAIEngine.ts
- core/autonomous-ai-widget/types.ts
- core/MessageBus.ts
- core/types/engine.types.ts
```

**映射配置**:
```json
{
  "document": "01-YYC3-PortAISys-智能浮窗-核心架构.md",
  "type": "one-to-many",
  "codeFiles": [
    "core/autonomous-ai-widget/AutonomousAIEngine.ts",
    "core/autonomous-ai-widget/types.ts",
    "core/MessageBus.ts",
    "core/types/engine.types.ts"
  ]
}
```

#### 2.2.2 多对一映射规则

**规则说明**:
- 多个文档文件对应一个代码文件
- 一个代码文件可能被多个文档引用
- 在代码文件中明确列出所有关联的文档

**映射示例**:
```
代码文件: core/AutonomousAIEngine.ts

关联文档文件:
- docs/YYC3-PortAISys-智能浮窗/00-YYC3-PortAISys-AutonomousAIEngine实现文档.md
- docs/YYC3-PortAISys-代码文档/01-YYC3-PortAISys-代码文档-智能AI浮窗系统.md
- docs/YYC3-PortAISys-缺失补全/YYC3-PortAISys-浮窗补全-一二章.md
```

**映射配置**:
```json
{
  "codeFile": "core/AutonomousAIEngine.ts",
  "type": "many-to-one",
  "documents": [
    "docs/YYC3-PortAISys-智能浮窗/00-YYC3-PortAISys-AutonomousAIEngine实现文档.md",
    "docs/YYC3-PortAISys-代码文档/01-YYC3-PortAISys-代码文档-智能AI浮窗系统.md",
    "docs/YYC3-PortAISys-缺失补全/YYC3-PortAISys-浮窗补全-一二章.md"
  ]
}
```

#### 2.2.3 层级映射规则

**规则说明**:
- 文档目录层级与代码目录层级保持一致
- 每个文档目录对应一个代码目录
- 支持多层嵌套映射

**映射示例**:
```
文档目录层级:
docs/YYC3-PortAISys-智能浮窗/
├── 00-YYC3-PortAISys-AutonomousAIEngine实现文档.md
├── 00-YYC3-PortAISys-ModelAdapter实现文档.md
├── 01-YYC3-PortAISys-智能浮窗-核心架构.md
├── 02-YYC3-PortAISys-智能浮窗-深度设计.md
└── 03-YYC3-PortAISys-智能浮窗-功能组件.md

代码目录层级:
core/
├── autonomous-ai-widget/
│   ├── AutonomousAIEngine.ts
│   └── types.ts
├── model/
│   ├── ModelAdapter.ts
│   ├── OpenAIAdapter.ts
│   ├── AnthropicAdapter.ts
│   └── types.ts
├── MessageBus.ts
└── types/
    └── engine.types.ts
```

### 2.3 特殊映射规则

#### 2.3.1 类型定义文件映射规则

**规则说明**:
- 类型定义文件（`types.ts`）与对应的文档文件映射
- 类型定义文件通常与主文件在同一目录下

**映射示例**:
```
文档文件: 00-YYC3-PortAISys-AutonomousAIEngine实现文档.md
代码文件:
- core/autonomous-ai-widget/AutonomousAIEngine.ts
- core/autonomous-ai-widget/types.ts

文档文件: 00-YYC3-PortAISys-ModelAdapter实现文档.md
代码文件:
- core/model/ModelAdapter.ts
- core/model/types.ts
```

#### 2.3.2 索引文件映射规则

**规则说明**:
- 索引文件（`index.ts`）与对应的目录文档映射
- 索引文件通常导出目录下的所有模块

**映射示例**:
```
文档文件: 01-YYC3-PortAISys-智能浮窗-核心架构.md
代码文件:
- core/autonomous-ai-widget/index.ts
- core/model/index.ts
- core/state-manager/index.ts
```

#### 2.3.3 配置文件映射规则

**规则说明**:
- 配置文件（`package.json`、`tsconfig.json` 等）与项目文档映射
- 配置文件通常与项目根目录文档映射

**映射示例**:
```
文档文件: 40-P0-02-P0-03-开发环境配置文档.md
代码文件:
- package.json
- tsconfig.json
- vite.config.ts
```

---

## 三、映射配置文件

### 3.1 映射配置文件结构

**配置文件位置**: `.doc-code-mapping.json`

**配置文件结构**:
```json
{
  "version": "1.0",
  "mappings": [
    {
      "id": "mapping-001",
      "document": "docs/YYC3-PortAISys-智能浮窗/00-YYC3-PortAISys-AutonomousAIEngine实现文档.md",
      "codeFiles": [
        "core/autonomous-ai-widget/AutonomousAIEngine.ts",
        "core/autonomous-ai-widget/types.ts"
      ],
      "type": "one-to-many",
      "syncEnabled": true,
      "lastSync": "2026-01-20T10:30:00Z",
      "syncStatus": "success"
    },
    {
      "id": "mapping-002",
      "document": "docs/YYC3-PortAISys-智能浮窗/00-YYC3-PortAISys-ModelAdapter实现文档.md",
      "codeFiles": [
        "core/model/ModelAdapter.ts",
        "core/model/OpenAIAdapter.ts",
        "core/model/AnthropicAdapter.ts",
        "core/model/types.ts"
      ],
      "type": "one-to-many",
      "syncEnabled": true,
      "lastSync": "2026-01-20T10:30:00Z",
      "syncStatus": "success"
    },
    {
      "id": "mapping-003",
      "document": "docs/YYC3-PortAISys-智能浮窗/01-YYC3-PortAISys-智能浮窗-核心架构.md",
      "codeFiles": [
        "core/AutonomousAIEngine.ts",
        "core/MessageBus.ts",
        "core/types/engine.types.ts"
      ],
      "type": "one-to-many",
      "syncEnabled": true,
      "lastSync": "2026-01-20T10:30:00Z",
      "syncStatus": "success"
    }
  ],
  "globalSettings": {
    "autoSync": true,
    "syncInterval": 300,
    "conflictResolution": "manual",
    "notificationEnabled": true
  }
}
```

### 3.2 映射配置字段说明

**字段说明**:

| 字段名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| id | string | 是 | 映射唯一标识符 |
| document | string | 是 | 文档文件路径 |
| codeFiles | array | 是 | 代码文件路径数组 |
| type | string | 是 | 映射类型（one-to-one、one-to-many、many-to-one） |
| syncEnabled | boolean | 否 | 是否启用同步（默认 true） |
| lastSync | string | 否 | 最后同步时间（ISO 8601 格式） |
| syncStatus | string | 否 | 同步状态（success、failed、pending） |

**全局设置字段说明**:

| 字段名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| autoSync | boolean | 否 | 是否自动同步（默认 true） |
| syncInterval | number | 否 | 同步间隔（秒，默认 300） |
| conflictResolution | string | 否 | 冲突解决策略（manual、auto、latest，默认 manual） |
| notificationEnabled | boolean | 否 | 是否启用通知（默认 true） |

---

## 四、映射规则实现

### 4.1 映射规则解析器

**实现代码**:
```typescript
interface MappingConfig {
  version: string;
  mappings: Mapping[];
  globalSettings: GlobalSettings;
}

interface Mapping {
  id: string;
  document: string;
  codeFiles: string[];
  type: 'one-to-one' | 'one-to-many' | 'many-to-one';
  syncEnabled?: boolean;
  lastSync?: string;
  syncStatus?: 'success' | 'failed' | 'pending';
}

interface GlobalSettings {
  autoSync?: boolean;
  syncInterval?: number;
  conflictResolution?: 'manual' | 'auto' | 'latest';
  notificationEnabled?: boolean;
}

class MappingRuleParser {
  private config: MappingConfig;

  constructor(configPath: string) {
    const configContent = fs.readFileSync(configPath, 'utf-8');
    this.config = JSON.parse(configContent);
  }

  getMappingById(id: string): Mapping | undefined {
    return this.config.mappings.find(m => m.id === id);
  }

  getMappingsByDocument(document: string): Mapping[] {
    return this.config.mappings.filter(m => m.document === document);
  }

  getMappingsByCodeFile(codeFile: string): Mapping[] {
    return this.config.mappings.filter(m => 
      m.codeFiles.includes(codeFile)
    );
  }

  getAllMappings(): Mapping[] {
    return this.config.mappings;
  }

  getGlobalSettings(): GlobalSettings {
    return this.config.globalSettings;
  }

  addMapping(mapping: Mapping): void {
    this.config.mappings.push(mapping);
    this.saveConfig();
  }

  updateMapping(id: string, updates: Partial<Mapping>): void {
    const index = this.config.mappings.findIndex(m => m.id === id);
    if (index !== -1) {
      this.config.mappings[index] = {
        ...this.config.mappings[index],
        ...updates
      };
      this.saveConfig();
    }
  }

  deleteMapping(id: string): void {
    this.config.mappings = this.config.mappings.filter(m => m.id !== id);
    this.saveConfig();
  }

  private saveConfig(): void {
    fs.writeFileSync(
      '.doc-code-mapping.json',
      JSON.stringify(this.config, null, 2)
    );
  }
}
```

### 4.2 映射规则验证器

**实现代码**:
```typescript
class MappingRuleValidator {
  validateMapping(mapping: Mapping): ValidationResult {
    const errors: string[] = [];

    if (!mapping.id) {
      errors.push('映射 ID 不能为空');
    }

    if (!mapping.document) {
      errors.push('文档路径不能为空');
    } else if (!fs.existsSync(mapping.document)) {
      errors.push(`文档文件不存在: ${mapping.document}`);
    }

    if (!mapping.codeFiles || mapping.codeFiles.length === 0) {
      errors.push('代码文件列表不能为空');
    } else {
      mapping.codeFiles.forEach(codeFile => {
        if (!fs.existsSync(codeFile)) {
          errors.push(`代码文件不存在: ${codeFile}`);
        }
      });
    }

    if (!['one-to-one', 'one-to-many', 'many-to-one'].includes(mapping.type)) {
      errors.push('映射类型必须是 one-to-one、one-to-many 或 many-to-one');
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  }

  validateConfig(config: MappingConfig): ValidationResult {
    const errors: string[] = [];

    if (!config.version) {
      errors.push('配置版本不能为空');
    }

    if (!config.mappings || config.mappings.length === 0) {
      errors.push('映射列表不能为空');
    } else {
      config.mappings.forEach(mapping => {
        const result = this.validateMapping(mapping);
        if (!result.isValid) {
          errors.push(...result.errors);
        }
      });
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  }
}

interface ValidationResult {
  isValid: boolean;
  errors: string[];
}
```

### 4.3 映射规则生成器

**实现代码**:
```typescript
class MappingRuleGenerator {
  generateMappingFromStructure(
    docsDir: string,
    codeDir: string
  ): Mapping[] {
    const mappings: Mapping[] = [];
    const docFiles = this.getAllMarkdownFiles(docsDir);

    docFiles.forEach((docFile, index) => {
      const relativeDocPath = path.relative(process.cwd(), docFile);
      const codeFiles = this.findRelatedCodeFiles(docFile, codeDir);

      if (codeFiles.length > 0) {
        mappings.push({
          id: `mapping-${String(index + 1).padStart(3, '0')}`,
          document: relativeDocPath,
          codeFiles: codeFiles.map(cf => path.relative(process.cwd(), cf)),
          type: codeFiles.length === 1 ? 'one-to-one' : 'one-to-many',
          syncEnabled: true,
          syncStatus: 'pending'
        });
      }
    });

    return mappings;
  }

  private getAllMarkdownFiles(dir: string): string[] {
    const files: string[] = [];

    const walk = (currentDir: string) => {
      const items = fs.readdirSync(currentDir);

      items.forEach(item => {
        const fullPath = path.join(currentDir, item);
        const stat = fs.statSync(fullPath);

        if (stat.isDirectory()) {
          walk(fullPath);
        } else if (item.endsWith('.md')) {
          files.push(fullPath);
        }
      });
    };

    walk(dir);
    return files;
  }

  private findRelatedCodeFiles(docFile: string, codeDir: string): string[] {
    const docFileName = path.basename(docFile, '.md');
    const codeFiles: string[] = [];

    const walk = (currentDir: string) => {
      const items = fs.readdirSync(currentDir);

      items.forEach(item => {
        const fullPath = path.join(currentDir, item);
        const stat = fs.statSync(fullPath);

        if (stat.isDirectory()) {
          walk(fullPath);
        } else if (
          (item.endsWith('.ts') || item.endsWith('.tsx')) &&
          (item.startsWith(docFileName) || 
           item === `${docFileName}.ts` ||
           item === `${docFileName}.tsx`)
        ) {
          codeFiles.push(fullPath);
        }
      });
    };

    walk(codeDir);
    return codeFiles;
  }
}
```

---

## 五、映射规则使用示例

### 5.1 创建映射规则

**示例代码**:
```typescript
const generator = new MappingRuleGenerator();
const mappings = generator.generateMappingFromStructure(
  'docs',
  'core'
);

const config: MappingConfig = {
  version: '1.0',
  mappings,
  globalSettings: {
    autoSync: true,
    syncInterval: 300,
    conflictResolution: 'manual',
    notificationEnabled: true
  }
};

fs.writeFileSync(
  '.doc-code-mapping.json',
  JSON.stringify(config, null, 2)
);
```

### 5.2 查询映射规则

**示例代码**:
```typescript
const parser = new MappingRuleParser('.doc-code-mapping.json');

const mapping = parser.getMappingById('mapping-001');
console.log('映射信息:', mapping);

const mappingsByDoc = parser.getMappingsByDocument(
  'docs/YYC3-PortAISys-智能浮窗/00-YYC3-PortAISys-AutonomousAIEngine实现文档.md'
);
console.log('文档映射:', mappingsByDoc);

const mappingsByCode = parser.getMappingsByCodeFile(
  'core/AutonomousAIEngine.ts'
);
console.log('代码映射:', mappingsByCode);
```

### 5.3 更新映射规则

**示例代码**:
```typescript
const parser = new MappingRuleParser('.doc-code-mapping.json');

parser.updateMapping('mapping-001', {
  lastSync: new Date().toISOString(),
  syncStatus: 'success'
});

parser.addMapping({
  id: 'mapping-004',
  document: 'docs/YYC3-PortAISys-智能浮窗/02-YYC3-PortAISys-智能浮窗-深度设计.md',
  codeFiles: [
    'core/state-manager/StateManager.ts',
    'core/task-scheduler/TaskScheduler.ts'
  ],
  type: 'one-to-many',
  syncEnabled: true,
  syncStatus: 'pending'
});
```

### 5.4 验证映射规则

**示例代码**:
```typescript
const validator = new MappingRuleValidator();
const parser = new MappingRuleParser('.doc-code-mapping.json');

const config = {
  version: '1.0',
  mappings: parser.getAllMappings(),
  globalSettings: parser.getGlobalSettings()
};

const result = validator.validateConfig(config);

if (result.isValid) {
  console.log('映射规则验证通过');
} else {
  console.error('映射规则验证失败:', result.errors);
}
```

---

## 六、映射规则最佳实践

### 6.1 命名规范

**文档命名规范**:
- 使用清晰的描述性名称
- 使用统一的命名前缀
- 使用连字符分隔单词
- 避免使用特殊字符

**代码命名规范**:
- 使用 PascalCase 命名类和接口
- 使用 camelCase 命名变量和函数
- 使用 kebab-case 命名目录
- 避免使用缩写

### 6.2 目录组织

**文档目录组织**:
- 按功能模块组织文档
- 按开发阶段组织文档
- 按文档类型组织文档
- 保持目录结构清晰

**代码目录组织**:
- 按功能模块组织代码
- 按技术层次组织代码
- 按代码类型组织代码
- 保持目录结构清晰

### 6.3 映射维护

**映射维护建议**:
- 定期检查映射规则的准确性
- 及时更新映射规则
- 删除不再使用的映射规则
- 保持映射规则的简洁性

---

## 七、总结

本文档详细设计了 YYC³ PortAISys 项目的文档与代码关联映射规则，包括：

1. **基础映射规则**: 文件名映射、目录结构映射、命名前缀映射
2. **高级映射规则**: 一对多映射、多对一映射、层级映射
3. **特殊映射规则**: 类型定义文件映射、索引文件映射、配置文件映射
4. **映射配置文件**: 配置文件结构、字段说明
5. **映射规则实现**: 映射规则解析器、验证器、生成器
6. **映射规则使用示例**: 创建、查询、更新、验证映射规则
7. **映射规则最佳实践**: 命名规范、目录组织、映射维护

通过这些映射规则，可以确保文档与代码的清晰关联，支持文档与代码的双向同步，实现文档与代码的版本一致性，提供文档与代码的变更追踪能力，确保文档与代码的实时同步。

---

**文档结束**
