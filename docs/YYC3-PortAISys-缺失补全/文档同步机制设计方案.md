# YYC³ PortAISys - 文档同步机制设计方案

## 文档信息

**文档名称**: 文档同步机制设计方案  
**文档版本**: v1.0  
**创建日期**: 2026-01-20  
**最后更新**: 2026-01-20  
**文档状态**: ✅ 已完成  
**负责团队**: 技术架构团队  
**负责人**: 技术架构师  

---

## 一、方案概述

### 1.1 设计目标

**核心目标**:
- 建立文档与代码的自动化同步机制
- 确保文档内容与代码实现保持一致性
- 支持文档与代码的双向同步
- 提供实时监控和异常提醒功能
- 建立可持续的维护机制

**预期效果**:
- 文档与代码同步延迟 < 5秒
- 文档与代码一致性准确率 100%
- 同步失败自动检测率 100%
- 异常提醒及时率 100%

### 1.2 设计原则

**设计原则**:
1. **自动化优先**: 尽可能实现自动化同步，减少人工干预
2. **双向同步**: 支持文档到代码和代码到文档的双向同步
3. **实时监控**: 实时监控文档和代码的变更
4. **异常处理**: 完善的异常检测和处理机制
5. **可扩展性**: 设计易于扩展和定制的架构
6. **易用性**: 提供简单易用的命令行工具

---

## 二、架构设计

### 2.1 系统架构

**架构图**:
```
┌─────────────────────────────────────────────────────────────┐
│                    文档同步机制架构                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌──────────────┐      ┌──────────────┐                   │
│  │  文件监控层   │      │  映射规则层   │                   │
│  │              │      │              │                   │
│  │  • 文档监控   │◄─────│  • 映射解析   │                   │
│  │  • 代码监控   │      │  • 规则验证   │                   │
│  │  • 变更检测   │      │  • 规则生成   │                   │
│  └──────────────┘      └──────────────┘                   │
│           │                       │                         │
│           ▼                       ▼                         │
│  ┌──────────────┐      ┌──────────────┐                   │
│  │  同步触发层   │      │  同步执行层   │                   │
│  │              │      │              │                   │
│  │  • 触发管理   │────►│  • 文档同步   │                   │
│  │  • 队列管理   │      │  • 代码同步   │                   │
│  │  • 防抖处理   │      │  • 冲突解决   │                   │
│  └──────────────┘      └──────────────┘                   │
│           │                       │                         │
│           ▼                       ▼                         │
│  ┌──────────────┐      ┌──────────────┐                   │
│  │  监控告警层   │      │  通知管理层   │                   │
│  │              │      │              │                   │
│  │  • 状态监控   │────►│  • 告警发送   │                   │
│  │  • 历史记录   │      │  • 通知管理   │                   │
│  │  • 异常检测   │      │  • 日志记录   │                   │
│  └──────────────┘      └──────────────┘                   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 模块设计

#### 2.2.1 文件监控模块

**功能描述**:
- 监控文档目录和代码目录的文件变更
- 检测文件的添加、修改、删除事件
- 支持递归监控子目录
- 提供实时变更通知

**技术实现**:
- 使用 `chokidar` 库实现文件系统监控
- 支持跨平台（Windows、macOS、Linux）
- 配置忽略规则，避免监控不必要的文件

**核心代码**:
```typescript
class FileWatcher {
  private docWatcher: chokidar.FSWatcher;
  private codeWatcher: chokidar.FSWatcher;

  watch(docsDir: string, codeDir: string) {
    this.docWatcher = chokidar.watch('**/*.md', {
      cwd: docsDir,
      ignored: /(^|[\/\\])\../,
      persistent: true
    });

    this.codeWatcher = chokidar.watch('**/*.{ts,tsx}', {
      cwd: codeDir,
      ignored: /(^|[\/\\])\../,
      persistent: true
    });

    this.docWatcher
      .on('add', (path) => this.handleDocChange('add', path))
      .on('change', (path) => this.handleDocChange('change', path))
      .on('unlink', (path) => this.handleDocChange('unlink', path));

    this.codeWatcher
      .on('add', (path) => this.handleCodeChange('add', path))
      .on('change', (path) => this.handleCodeChange('change', path))
      .on('unlink', (path) => this.handleCodeChange('unlink', path));
  }
}
```

#### 2.2.2 映射规则模块

**功能描述**:
- 解析和管理文档与代码的映射关系
- 验证映射规则的有效性
- 支持映射规则的增删改查
- 自动生成映射规则

**技术实现**:
- 使用 JSON 格式存储映射配置
- 提供映射规则解析器和验证器
- 支持基于文件名和目录结构的自动映射生成

**核心代码**:
```typescript
class MappingRuleParser {
  private config: MappingConfig;

  constructor(configPath: string) {
    this.loadConfig(configPath);
  }

  getMappingById(id: string): Mapping | undefined {
    return this.config.mappings.find(m => m.id === id);
  }

  getMappingsByDocument(document: string): Mapping[] {
    return this.config.mappings.filter(m => m.document === document);
  }

  addMapping(mapping: Mapping): void {
    this.config.mappings.push(mapping);
    this.saveConfig();
  }
}
```

#### 2.2.3 同步触发模块

**功能描述**:
- 管理同步触发事件
- 实现同步队列管理
- 提供防抖处理机制
- 支持手动和自动同步

**技术实现**:
- 使用事件驱动架构
- 实现同步队列和防抖机制
- 支持异步同步处理

**核心代码**:
```typescript
class BidirectionalSyncTrigger extends EventEmitter {
  private syncQueue: FileChangeEvent[] = [];
  private isProcessing: boolean = false;
  private debounceTimer: NodeJS.Timeout | null = null;

  async handleDocChange(type: string, path: string) {
    const event: FileChangeEvent = {
      type,
      path,
      timestamp: new Date().toISOString()
    };

    this.addToSyncQueue(event);
  }

  private addToSyncQueue(event: FileChangeEvent) {
    this.syncQueue.push(event);
    this.debouncedProcess();
  }

  private debouncedProcess() {
    if (this.debounceTimer) {
      clearTimeout(this.debounceTimer);
    }

    this.debounceTimer = setTimeout(() => {
      this.processSyncQueue();
    }, this.debounceDelay);
  }
}
```

#### 2.2.4 同步执行模块

**功能描述**:
- 执行文档到代码的同步
- 执行代码到文档的同步
- 提取和更新文档/代码信息
- 处理同步冲突

**技术实现**:
- 使用正则表达式提取文档和代码信息
- 实现智能内容更新算法
- 提供冲突检测和解决机制

**核心代码**:
```typescript
class SyncExecutor {
  async syncDocToCode(docPath: string, codePaths: string[]) {
    const docContent = fs.readFileSync(docPath, 'utf-8');
    const extractedInfo = this.extractCodeInfoFromDoc(docContent);

    for (const codePath of codePaths) {
      const codeContent = fs.readFileSync(codePath, 'utf-8');
      const updatedContent = this.updateCodeWithDocInfo(codeContent, extractedInfo);
      fs.writeFileSync(codePath, updatedContent, 'utf-8');
    }
  }

  async syncCodeToDoc(codePath: string, docPath: string) {
    const codeContent = fs.readFileSync(codePath, 'utf-8');
    const extractedInfo = this.extractDocInfoFromCode(codeContent);

    const docContent = fs.readFileSync(docPath, 'utf-8');
    const updatedContent = this.updateDocWithCodeInfo(docContent, extractedInfo);
    fs.writeFileSync(docPath, updatedContent, 'utf-8');
  }
}
```

#### 2.2.5 监控告警模块

**功能描述**:
- 监控同步状态
- 检测同步异常
- 记录同步历史
- 发送告警通知

**技术实现**:
- 定时检查同步状态
- 维护同步历史记录
- 实现告警阈值机制
- 提供多种通知渠道

**核心代码**:
```typescript
class SyncMonitor extends EventEmitter {
  private status: SyncStatus;
  private syncHistory: SyncResult[] = [];

  startMonitoring() {
    this.checkTimer = setInterval(() => {
      this.checkSyncStatus();
    }, this.config.checkInterval);
  }

  private checkSyncStatus() {
    const mappings = this.parser.getAllMappings();
    const failedCount = mappings.filter(m => m.syncStatus === 'failed').length;

    if (failedCount >= this.config.alertThreshold) {
      this.sendAlert({
        type: 'error',
        title: '同步失败告警',
        message: `检测到 ${failedCount} 个映射同步失败`
      });
    }
  }
}
```

#### 2.2.6 通知管理模块

**功能描述**:
- 管理通知消息
- 提供多种通知渠道
- 支持通知历史查询
- 实现通知优先级

**技术实现**:
- 使用事件驱动架构
- 支持控制台、邮件、Slack 等通知渠道
- 实现通知队列和去重机制

**核心代码**:
```typescript
class NotificationManager extends EventEmitter {
  private notifications: Notification[] = [];

  send(notification: Notification) {
    this.notifications.push(notification);
    this.emit('notification', notification);
    this.logNotification(notification);
  }

  private logNotification(notification: Notification) {
    const icon = this.getNotificationIcon(notification.type);
    console.log(`${icon} ${notification.title}: ${notification.message}`);
  }
}
```

---

## 三、技术实现

### 3.1 技术栈

**核心技术栈**:
- **运行时**: Node.js 18+
- **语言**: TypeScript 5.3+
- **文件监控**: chokidar 3.5+
- **命令行**: commander 11.1+
- **日志**: ora 5.4+, chalk 4.1+
- **交互**: inquirer 8.2+
- **事件**: eventemitter3 5.0+
- **版本控制**: simple-git 3.20+

**开发工具**:
- **构建工具**: TypeScript Compiler
- **测试框架**: Vitest 1.0+
- **代码检查**: ESLint 8.54+
- **代码格式化**: Prettier 3.1+

### 3.2 目录结构

```
tools/doc-code-sync/
├── package.json              # 项目配置文件
├── tsconfig.json            # TypeScript 配置文件
├── README.md               # 使用说明文档
├── src/
│   ├── index.ts            # 命令行入口
│   ├── types.ts            # 类型定义
│   ├── mapping-parser.ts    # 映射规则解析器
│   ├── sync-trigger.ts     # 同步触发器
│   └── monitor.ts          # 监控告警器
├── dist/                   # 编译输出目录
└── tests/                  # 测试目录
```

### 3.3 核心功能实现

#### 3.3.1 文档到代码同步

**实现逻辑**:
1. 监控文档文件变更
2. 提取文档中的关键信息（功能描述、API 接口、使用示例等）
3. 根据映射规则找到对应的代码文件
4. 更新代码文件的注释和文档字符串
5. 记录同步结果

**代码示例**:
```typescript
private extractCodeInfoFromDoc(docContent: string): any {
  const info: any = {};

  const descriptionMatch = docContent.match(/## 功能描述\s*\n([\s\S]*?)(?=\n##|$)/);
  if (descriptionMatch) {
    info.description = descriptionMatch[1].trim();
  }

  const apiMatch = docContent.match(/## API 接口\s*\n([\s\S]*?)(?=\n##|$)/);
  if (apiMatch) {
    info.api = apiMatch[1].trim();
  }

  return info;
}

private updateCodeWithDocInfo(codeContent: string, docInfo: any): string {
  let updatedContent = codeContent;

  if (docInfo.description) {
    const classMatch = updatedContent.match(/(export\s+(?:class|interface|function)\s+\w+)/);
    if (classMatch) {
      const comment = `/**\n * ${docInfo.description.replace(/\n/g, '\n * ')}\n */\n`;
      updatedContent = updatedContent.replace(classMatch[1], comment + classMatch[1]);
    }
  }

  return updatedContent;
}
```

#### 3.3.2 代码到文档同步

**实现逻辑**:
1. 监控代码文件变更
2. 提取代码中的关键信息（类名、方法名、注释等）
3. 根据映射规则找到对应的文档文件
4. 更新文档文件的相关章节
5. 记录同步结果

**代码示例**:
```typescript
private extractDocInfoFromCode(codeContent: string): any {
  const info: any = {};

  const classMatch = codeContent.match(/export\s+(?:class|interface|function)\s+(\w+)/);
  if (classMatch) {
    info.className = classMatch[1];
  }

  const commentMatch = codeContent.match(/\/\*\*[\s\S]*?\*\//);
  if (commentMatch) {
    const commentText = commentMatch[0]
      .replace(/\/\*\*/, '')
      .replace(/\*\//g, '')
      .split('\n')
      .map(line => line.replace(/^\s*\*\s?/, '').trim())
      .filter(line => line.length > 0)
      .join('\n');

    info.description = commentText;
  }

  const methodMatches = codeContent.matchAll(/(?:public|private|protected)?\s*(?:async\s+)?(\w+)\s*\([^)]*\)\s*:\s*\w+/g);
  info.methods = Array.from(methodMatches).map(match => match[1]);

  return info;
}

private updateDocWithCodeInfo(docContent: string, codeInfo: any): string {
  let updatedContent = docContent;

  if (codeInfo.description) {
    const descSection = `## 功能描述\n\n${codeInfo.description}\n`;
    updatedContent = this.replaceSection(updatedContent, '功能描述', descSection);
  }

  if (codeInfo.methods && codeInfo.methods.length > 0) {
    const methodsSection = `## 方法列表\n\n${codeInfo.methods.map(m => `- \`${m}\``).join('\n')}\n`;
    updatedContent = this.replaceSection(updatedContent, '方法列表', methodsSection);
  }

  return updatedContent;
}
```

#### 3.3.3 冲突检测与解决

**实现逻辑**:
1. 检测文档和代码的变更冲突
2. 根据配置的冲突解决策略处理冲突
3. 记录冲突解决结果
4. 通知用户冲突情况

**代码示例**:
```typescript
private detectConflict(docPath: string, codePath: string): boolean {
  const docStat = fs.statSync(docPath);
  const codeStat = fs.statSync(codePath);

  const mapping = this.parser.getMappingByDocument(docPath);
  if (!mapping || !mapping.lastSync) {
    return false;
  }

  const lastSyncTime = new Date(mapping.lastSync);
  const docModified = docStat.mtime > lastSyncTime;
  const codeModified = codeStat.mtime > lastSyncTime;

  return docModified && codeModified;
}

private resolveConflict(docPath: string, codePath: string, strategy: string) {
  switch (strategy) {
    case 'manual':
      console.log('需要手动解决冲突');
      break;
    case 'auto':
      this.autoResolveConflict(docPath, codePath);
      break;
    case 'latest':
      this.resolveByLatest(docPath, codePath);
      break;
  }
}
```

---

## 四、使用指南

### 4.1 安装

**安装步骤**:
```bash
# 进入工具目录
cd tools/doc-code-sync

# 安装依赖
npm install

# 构建项目
npm run build

# 全局安装（可选）
npm link
```

### 4.2 初始化配置

**初始化命令**:
```bash
# 初始化文档同步配置
yyc3-doc-sync init

# 指定文档和代码目录
yyc3-doc-sync init --docs-dir docs --code-dir core
```

**初始化过程**:
1. 扫描文档目录和代码目录
2. 自动生成映射规则
3. 验证映射规则有效性
4. 创建配置文件 `.doc-code-mapping.json`

### 4.3 启动监控

**启动命令**:
```bash
# 启动文件监控
yyc3-doc-sync watch

# 指定文档和代码目录
yyc3-doc-sync watch --docs-dir docs --code-dir core

# 指定配置文件
yyc3-doc-sync watch --config .doc-code-mapping.json
```

**监控过程**:
1. 启动文档和代码文件监控
2. 检测文件变更事件
3. 自动触发同步操作
4. 实时显示同步结果

### 4.4 手动同步

**手动同步命令**:
```bash
# 同步指定文件
yyc3-doc-sync sync docs/YYC3-PortAISys-智能浮窗/00-YYC3-PortAISys-AutonomousAIEngine实现文档.md

# 同步代码文件
yyc3-doc-sync sync core/AutonomousAIEngine.ts
```

### 4.5 查看状态

**状态查询命令**:
```bash
# 查看同步状态
yyc3-doc-sync status

# 查看所有映射规则
yyc3-doc-sync list
```

### 4.6 管理映射规则

**添加映射规则**:
```bash
# 添加新的映射规则
yyc3-doc-sync add
```

**删除映射规则**:
```bash
# 删除映射规则
yyc3-doc-sync remove mapping-001
```

---

## 五、配置说明

### 5.1 配置文件结构

**配置文件位置**: `.doc-code-mapping.json`

**配置文件示例**:
```json
{
  "version": "1.0",
  "mappings": [
    {
      "id": "mapping-001",
      "document": "docs/YYC3-PortAISys-智能浮窗/00-YYC3-PortAISys-AutonomousAIEngine实现文档.md",
      "codeFiles": [
        "core/autonomous-ai-widget/AutonomousAIEngine.ts",
        "core/autonomous-ai-widget/types.ts"
      ],
      "type": "one-to-many",
      "syncEnabled": true,
      "lastSync": "2026-01-20T10:30:00Z",
      "syncStatus": "success"
    }
  ],
  "globalSettings": {
    "autoSync": true,
    "syncInterval": 300,
    "conflictResolution": "manual",
    "notificationEnabled": true
  }
}
```

### 5.2 配置参数说明

**映射规则参数**:

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| id | string | 是 | 映射唯一标识符 |
| document | string | 是 | 文档文件路径 |
| codeFiles | array | 是 | 代码文件路径数组 |
| type | string | 是 | 映射类型（one-to-one、one-to-many、many-to-one） |
| syncEnabled | boolean | 否 | 是否启用同步（默认 true） |
| lastSync | string | 否 | 最后同步时间（ISO 8601 格式） |
| syncStatus | string | 否 | 同步状态（success、failed、pending） |

**全局设置参数**:

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| autoSync | boolean | 否 | 是否自动同步（默认 true） |
| syncInterval | number | 否 | 同步间隔（秒，默认 300） |
| conflictResolution | string | 否 | 冲突解决策略（manual、auto、latest，默认 manual） |
| notificationEnabled | boolean | 否 | 是否启用通知（默认 true） |

---

## 六、最佳实践

### 6.1 文档编写规范

**文档结构规范**:
```markdown
# 文档标题

## 功能描述
[功能描述内容]

## API 接口
[API 接口说明]

## 使用示例
[使用示例代码]

## 注意事项
[注意事项说明]
```

**文档命名规范**:
- 使用清晰的描述性名称
- 使用统一的命名前缀
- 使用连字符分隔单词
- 避免使用特殊字符

### 6.2 代码编写规范

**代码注释规范**:
```typescript
/**
 * 类/函数/方法的描述
 * 
 * @param paramName - 参数说明
 * @returns 返回值说明
 * @throws {Error} 错误说明
 */
export class ClassName {
  // 代码实现
}
```

**代码命名规范**:
- 使用 PascalCase 命名类和接口
- 使用 camelCase 命名变量和函数
- 使用 kebab-case 命名目录
- 避免使用缩写

### 6.3 同步使用建议

**同步建议**:
1. **及时保存**: 编辑完成后及时保存文档和代码
2. **定期检查**: 定期检查同步状态和历史记录
3. **处理冲突**: 及时处理同步冲突
4. **更新映射**: 及时更新映射规则
5. **查看日志**: 定期查看同步日志

---

## 七、故障排除

### 7.1 常见问题

**问题1: 同步失败**
- **原因**: 文件不存在或权限不足
- **解决**: 检查文件路径和权限

**问题2: 映射规则无效**
- **原因**: 映射规则配置错误
- **解决**: 检查映射规则配置文件

**问题3: 监控不工作**
- **原因**: 文件监控服务未启动
- **解决**: 重新启动监控服务

**问题4: 冲突无法解决**
- **原因**: 冲突解决策略配置不当
- **解决**: 调整冲突解决策略或手动解决

### 7.2 日志查看

**日志文件位置**: `./sync-monitor.log`

**日志内容示例**:
```
[2026-01-20T10:30:00.000Z] 监控服务已启动
[2026-01-20T10:30:05.000Z] 同步结果: 成功 - 同步完成: 1 个映射
[2026-01-20T10:30:10.000Z] 告警: [error] 同步失败告警 - 检测到 5 个映射同步失败
```

---

## 八、总结

本文档详细设计了 YYC³ PortAISys 项目的文档同步机制，包括：

1. **方案概述**: 设计目标、设计原则
2. **架构设计**: 系统架构、模块设计
3. **技术实现**: 技术栈、目录结构、核心功能实现
4. **使用指南**: 安装、初始化、启动监控、手动同步、查看状态、管理映射规则
5. **配置说明**: 配置文件结构、配置参数说明
6. **最佳实践**: 文档编写规范、代码编写规范、同步使用建议
7. **故障排除**: 常见问题、日志查看

通过这个文档同步机制，可以确保文档与代码的清晰关联，支持文档与代码的双向同步，实现文档与代码的版本一致性，提供文档与代码的变更追踪能力，确保文档与代码的实时同步。

---

**文档结束**
